@startuml Silence Radio
package "controleurs" {
    class ApplicationRadio {
    	- sceneCourante : Scene
    	- sceneMenu : Scene
    	- sceneEmetteur : Scene
    	- sceneRecepteur : Scene
    	- stage : Stage
    	- vueEmetteur : ControleurVueEmetteur
    	- vueRecepteur : ControleurVueRecepteur
    	- vueMenu : ControleurVueMenu
    	- redimensionnable : boolean = true
        + void start(Stage stagePrincipal)
        + {static} void main()
        - void showVueMenu(Stage stage)
        + void showVueEmetteur()
        + void showVueRecepteur()
        - void demarrageStage(String titre, boolean redimension, Scene scene)
        + Stage getStage()
        + Stage getSceneCourante()
        + void setSceneCourante()
        - void setOptionRetour()
    }
    
    class ControleurEnvoi {
        - {static} void envoyer(Byte[] bytes)
    }
    
    note top of ControleurReception : Le corps de cette classe reste à déterminer
    class ControleurReception{
        + void ControleurReception()
    }
}

package "vue" {
    class ControleurVueEmetteur {
    	- borderPaneRoot : BorderPane
    	- btnSelectionner : JFXButton
    	- btnEnvoyer : JFXButton
    	- btnAnnuler : JFXButton
    	- btnCalibrer : JFXButton
    	- textFieldTempsUnBit : JFXTextField
    	- labelProgress : Label
    	- labelVitesseFichier : Label
    	- labelTempsEstim : Label
    	- vboxMessages : VBox
    	- paneAnimation : Pane
    	- progressBar : ProgressBar
    	- hboxProgressBar : HBox
        - application : ApplicationRadio = null
        + {static} final ADRESSE_VUE_EMETTEUR : String = "/vues/Vue_Emetteur.fxml"
        - final fileChooser : FileChooser = new FileChooser()
        - file : File
        - nbrMessage : int = 0
        - generateurSon : GenerateurSon
        - lecteurSon : LecteurSon
        - dureeSonBit : FloatProperty = new SimpleFloatProperty(1f)
        - threadSon : Thread
        - animProgressBar : AnimationProgressBar
        + void setApplication(ApplicationRadio application)
        + BorderPane getBorderPaneRoot()
        - void clickedBtnEnvoyer(ActionEvent event)
        - void ajoutLabel(Label l)
        - void clickedBtnSelect(ActionEvent event)
        - void clickedCalibrer(ActionEvent event)
        + void bindTextField()
        + void bindProgressBar()
        - void clickedBtnAnnuler(ActionEvent event)
        + String getEmplacementFichierSelect()
        - void afficherErreur(String emplacement, String detail, Exception ex)
    }

    class ControleurVueRecepteur {
        - borderPaneRoot : BorderPane
    	- btnSelectionner : JFXButton
    	- btnEcouter : JFXButton
    	- btnAnnuler : JFXButton
    	- btnCalibrer : JFXButton
    	- vboxMessages : VBox
    	- labelProgress : Label
    	- progressBar : ProgressBar
    	- hboxProgressBar : HBox
    	- textFieldTempsRecep : JFXTextField
    	- textFieldInterv : JFXTextField
        - application : ApplicationRadio = null
        + {static} final ADRESSE_VUE_RECEPTEUR : String = "/vues/Vue_Recepteur.fxml"
        - final FileChooser : FileChooser = new FileChooser()
        - file : File
        - nbrMessage : int = 0
        - dureeIntervalleRecep : FloatProperty = new SimpleFloatProperty(1f)
        - tempsReception : LongProperty = new SimpleLongProperty(1)
        - animProgress : AnimationProgressBar
        - threadEcoute : Thread
        - ecouteur : EcouteurDeReception
        + ControleurVueReception()
        + void setApplication(ApplicationRadio application)
        + BorderPane getBorderPaneRoot()
        - void clickedBtnSelect(ActionEvent event)
        - void clickedBtnEcouter(ActionEvent event)
        - void clickedBtnAnnuler(ActionEvent event)
        - void clickedBtnCalibrer(ActionEvent event)
        + void bindProgressBar()
        + void bindTextView()
        + String getEmplacementFichierSelect()
        - void ajoutLabel(Label l)
        - void afficherErreur(String emplacement, String details, Exception ex)
        - void afficherErreur(String emplacement, String details)
    }

    class ControleurVueMenu {
    	- darkNGreen RadioMenuItem
    	- blueNRed RadioMenuItem
        - vboxRoot : VBox
        - btnEmettre : JFXButton
        - btnReception : JFXButton
        - themeCourant : String = DARK_N_GREEN
        + {static} final DARK_N_GREEN : String = "/styles/DarkNGreen.css"
        + {static} final POWDER_BLUE : String = "/styles/PowderBlue.css"
        - application : ApplicationRadio = null
        + {static} final ADRESSE_VUE_MENU : String = "/vues/Vue_Menu.fxml"
        + void setApplication(ApplicationRadio application)
        + VBox getVboxRoot()
        - void clickedBtnEmettre(ActionEvent event)
        - void clickedBtnReception(ActionEvent event)
        - void selectedDarkNGreen(ActionEvent event)
        - void selectedBlueNRed(ActionEvent event)
        + String getThemeCourant()
    }
}

package "modeles" {
    class RepresentationBinaire {
		- OctetBinaire[] octets
		- int octetCourant
		+ RepresentationBinaire(byte[] bytes)
		+ RepresentationBinaire(OctetBinaire[] octets)
		+ OctetBinaire[] getOctets()
		+ boolean hasNext()
		+ OctetBinaire next()
		+ Iterator<OctetBinaire> iterator()
		- {static} boolean validerOctets(byte[] octets)
		- {static} boolean validerOctets(OctetBinaire[] octets)
		+ String toString()
	}

    class OctetBinaire {
        - bits : byte[]
        - representationDecimale : byte
        - bitCourant : int
        + {static} {final} BITS_DANS_OCTET : byte
        + OctetBinaire(byte b)
        + OctetBinaire(byte[] bits)
        - void calculerBits(byte b)
        - byte[] decABin(byte b, byte[] representationBin, int index)
        + byte[] decABin(byte b)
        + byte[] getBits()
        + byte[] complementerADeux(byte[] bits)
        - void calculerRepresentationDecimal()
        + byte getOctetEnDecimal()
        + String toString()
        + boolean equals(Object obj)
        + Iterator<Byte> iterator()
        + boolean hasNext()
        + Byte next()
        - {static} boolean validerBits(byte[] bits)
        + {static} boolean validerBit(byte b)
    }
}

package "modeles.emetteur" {
    class GenerateurSon {
        - repr : RepresentationBinaire
        - donneesSon0 : byte[]
        - donneesSon1 : byte[]
        + GenerateurSon(RepresentationBinaire repr, float dureeEnSec)
        + void calculerSonsPourBits(float dureeEnSec)
        + byte[][] getDonneesSon()
        + {static} boolean validerRepresentation(RepresentationBinaire repr)
        + {static} boolean validerDureeEnSec(float duree)
    }

    class LecteurSon {
        - donneesSons : byte[][]
        - af : AudioFormat
        - sdl : SourceDataLine
        - dureeEnSec : float
        + LecteurSon(byte[][] donneesSons, float dureeEnSec)
        + void lireSons()
        - void creerAudioFormat()
        - void creerSourceDataLine()
        - void preparerDataLineAEnvoi()
        - void fermerDataLine()
        + {static} boolean validerDonneesSon(byte[][] donnees)
        + {static} boolean validerDuree(float duree)
    }
    
    class Calibreur {
		+ {static} final float TEMPS_PAR_BIT = 0.125f
		+ {static} void calibrerTout()
		+ {static} void calibrerUns()
		+ {static} void calibrerZeros()
		- {static} void calibrerAvecFichier(File fich)
	}
}

package "modeles.receveur" {
	class ReconstitueurDeMessages {
		- byte[] octetEnConstruction
		- int indiceConstructionCourant
		- List<OctetBinaire> octetsComplets
		+ ReconstitueurDeMessages()
		+ void ajouterBit(byte b)
		+ RepresentationBinaire getRepresentationBinaire()
	}

	class EcouteurDeReception {
		- ReconstitueurDeMessages rdm
		- int indiceFreqVoulue
		- double volumeMinUn = 1
		- double volumeMinZero = 1
		+ {static} final int WINDOW_SIZE = 512
		+ {static} final int OVERLAP = 0
		+ {static} final double FREQUENCE_RECEPTION = 3300.0
		- double tempsParBit = 0
		- {static} final String NOM_FICH_SON = "audio.wav"
		+ EcouteurDeReception(double tempsParBit)
		+ void ecouter(long millisecondes)
		+ ReconstitueurDeMessages getReconstitueur()
		- long nbBitsVu = 0
		+ void reconstruire()
		- Optional<Byte> analyserSignal(FFTFrame frame)
		- double calibrerVolumeBit(byte unOuZero, double diminutionSup)
		+ void calibrer(double diminutionSup)
		- int getIndiceBin(double frequence)
		- FFTResult getResultatFFT(int windowSize, double overlap)
		- {static} boolean validerVolumeMin(double volumeMin)
	}
}

package "passerelle" {
    class PasserelleFichier{
        + {static} byte[] lireOctets(File fichier)
        + {static} void ecrireOctets(byte[] octets)
        + {static} void ecrireOctets(RepresentationBinaire binaire)
        + {static} File obtenirFichier(String chemin)
    }
}

package "tests" {
	class TestGenerateurSon {
		+ {static} void setUp()
		+ void testGenerateurSon()
		+ void testGenerateurSonInvalide()
		+ void testCalculerSonsPourBits()
		+ void testGetDonneesSon()
	}
	
	class TestLecteurSon {
		+ void testLecteurSon()
		+ void testLecteurSonInvalide()
		+ void testValiderDonneesSon()
		+ void testValiderDuree()
	}

    class TestOctetBinaire {
        ob : OctetBinaire
        + void testOctetBinaireValide()
        + void testOctetBinaireInvalide()
        + void testCalculerBits()
        + void testEquals()
        + void testToString()
        + void testHasNextEtNext()
        + void testIterator()
        + void testDecABin()
        + void testGetOctetEnDecimal()
        + void testValiderBit()
    }

    class TestPasserelleFichier {
        + void testLireFichier()
        + void testEcrireFichier()
    }

    class TestRepresentationBinaire {
        rb : RepresentationBinaire
        rb1 : RepresentationBinaire
        octets : byte[] = {0, 1, 2, 3};
        + void testRepresentationBinaire()
        + void testRepresentationBinaireInvalide()
        + void testGetOctets()
        + void testHasNextEtNext()
        + void testIterator()
    }

    class TestReconstitueurDeMessages {
        rdm : ReconstitueurDeMessages
        + void testReconstitueurDeMessages()
        + void testAjouterBit()
        + void testGetRepresentationBinaire()
    }

    class TestSuite {
    }
}

interface "Iterable<OctetBinaire>" as iterableOB {
    + OctetBinaire next()
    + boolean hasNext()
}
interface "Iterator<OctetBinaire>" as iteratorOB {
    + Iterator<OctetBinaire> iterator()
}
interface "Iterable<Byte>" as iterableBY {
    + Byte next()
    + boolean hasNext()
}
interface "Iterator<Byte>" as iteratorBY {
    + Iterator<Byte> iterator()
}

ApplicationRadio --> ControleurEnvoi
ControleurEnvoi --> PasserelleFichier
ControleurEnvoi --> RepresentationBinaire

OctetBinaire --|> iterableBY
OctetBinaire --|> iteratorBY


RepresentationBinaire --> OctetBinaire
RepresentationBinaire --|> iterableOB
RepresentationBinaire --|> iteratorOB

GenerateurSon --> RepresentationBinaire
GenerateurSon --> OctetBinaire

LecteurSon --> GenerateurSon

ControleurReception --> PasserelleFichier
ControleurReception --> EcouteurSignaux

TestGenerateurSon --> GenerateurSon
TestLecteurSon --> LecteurSon
TestReconstitueurDeMessages --> ReconstitueurDeMessages

EcouteurDeReception --> ReconstitueurDeMessages

TestOctetBinaire --> OctetBinaire
TestPasserelleFichier --> PasserelleFichier
TestRepresentationBinaire --> RepresentationBinaire
@enduml